# Issueの計画

# DAILY-SCRUM単位のタスク
- ISSUE.mdを元に、開発タスクをデイリースクラム単位に分解する
- [x] 現状の.clinerulesのworkflowとdocumentを調査し、test-and-lintの実行箇所を特定する
- [x] 現状のpackage.jsonのknipやtsr、test-and-lintの設定を確認する
- [x] 未使用コードの扱いに関する改善案を検討し、最適なアプローチを決定する
- [x] .clinerulesのworkflowやdocumentを改善案に基づいて修正する
- [x] package.jsonのknipやtsr、test-and-lintの設定を改善案に基づいて変更する
- [x] 変更後の動作を確認し、意図通りに動作することを検証する

## 改善案の詳細分析

### 前提条件の整理
- **目的**: 粒度の細かいPR提出を可能にする
- **課題**: 将来使う予定のコードが未使用として削除されてしまう
- **制約**: コード品質を維持し、真の未使用コードは検出・削除したい

### 改善案の比較検討

#### 案1: test-and-lintを毎回実行 + 未使用コードを警告のみにする

**実装方法:**
- `npm run test-and-lint`を2段階に分割
  - `npm run test-and-lint:check`: 警告のみ（knip --no-exit-code）
  - `npm run test-and-lint:fix`: 自動修正（従来通り）
- ワークフローでは`test-and-lint:check`を使用
- PRマージ前やissue完了時に`test-and-lint:fix`を手動実行

**メリット:**
- 未使用コードを常に把握できる
- AIタスク完了時の自動化が維持される
- 段階的なアプローチで品質と柔軟性を両立

**デメリット:**
- 警告が多いと見落としのリスク
- 最終的な手動実行を忘れる可能性

**評価:** ★★★★☆

#### 案2: test-and-lintの実行タイミングを開発者判断にする

**実装方法:**
- ワークフローから`test-and-lint`を削除
- `npm run test:all`のみ必須化
- `npm run test-and-lint`は開発者が任意のタイミングで実行

**メリット:**
- 完全な柔軟性
- シンプルな実装

**デメリット:**
- 未使用コードが蓄積するリスクが高い
- AI駆動開発では実行忘れが発生しやすい
- 品質保証の観点で懸念

**評価:** ★★☆☆☆

#### 案3: knipの設定で意図的な未使用コードを管理

**実装方法:**
- knip.jsonに`ignoreExportsUsedInFile`オプションを追加
- 意図的な未使用コードに特定のコメント（例: `@wip`, `@future-use`）を付与
- コメント付きコードをknipのignoreパターンに追加

**メリット:**
- 意図の明示化（ドキュメントとしても機能）
- 自動チェックを維持しつつ柔軟性を確保
- 真の未使用コードは検出される

**デメリット:**
- コメントの付与を忘れるリスク
- knipの設定が複雑になる可能性

**評価:** ★★★☆☆

#### 案4: 段階的なワークフロー（推奨案）

**実装方法:**
1. デイリースクラム完了時（PRレビュー前）:
   - `npm run test:all`: 必須
   - `npm run unused:check`: 警告のみ（新規スクリプト）
   - 未使用コードがあっても警告表示のみでattempt_completion可能

2. issue完了時（PRマージ前）:
   - `npm run test-and-lint`: 必須（従来通り）
   - すべての未使用コードを解決

**具体的な実装:**
- package.jsonに追加:
  ```json
  "unused:check": "npm run knip:all --no-exit-code && echo '\n警告: 未使用コードが検出されました。issue完了時に解決してください。'"
  ```
- test-and-lint-before-complete.mdを2種類に分割:
  - `workflow:test-before-complete.md`: デイリースクラム用
  - `workflow:test-and-lint-before-complete.md`: issue完了用

**メリット:**
- 粒度の細かいPRが可能
- 未使用コードを常に把握
- issue単位で品質保証
- AI駆動開発との相性が良い

**デメリット:**
- ワークフローが少し複雑になる
- 2種類のチェックを理解する必要がある

**評価:** ★★★★★

#### 案5: knipの設定カスタマイズ + ワークフロー分離

**実装方法:**
- knip.jsonを2つ用意:
  - `knip.json`: 厳格モード（issue完了時）
  - `knip.daily.json`: 寛容モード（デイリースクラム用、export未使用を許容）
- package.jsonに追加:
  ```json
  "knip:daily": "knip --config knip.daily.json",
  "unused:daily": "npm run knip:daily && npm run tsr:check && npm run lint",
  "test-daily": "npm run unused:daily && npm run test:all"
  ```

**メリット:**
- 設定レベルでの制御
- export未使用を明示的に許容
- import未使用や型エラーは検出

**デメリット:**
- 設定ファイルの管理が複雑
- knip.jsonの重複管理

**評価:** ★★★☆☆

### 推奨アプローチ: 案4（段階的なワークフロー）

**理由:**
1. **開発体験（DX）**: 粒度の細かいPRが可能
2. **品質保証**: issue単位で完全なクリーンアップを強制
3. **可視性**: 常に未使用コードを把握できる
4. **実装コスト**: 比較的シンプル
5. **AI駆動開発**: ワークフローの自動化が維持される

### 実装計画

#### フェーズ1: package.jsonの修正
1. `unused:check`スクリプトを追加
2. `test-daily`スクリプトを追加（test:all + unused:check）

#### フェーズ2: ワークフローファイルの修正
1. `test-before-complete.md`を新規作成（デイリースクラム用）
2. `test-and-lint-before-complete.md`を更新（issue完了用のみ）
3. `workflow:code-according-to-the-rules.md`を更新（test-before-completeを参照）
4. issue完了時のワークフローファイルを特定し、test-and-lint-before-completeの実行を追加

#### フェーズ3: 動作検証
1. デイリースクラムでのテスト実行を確認
2. 未使用コード検出時の警告表示を確認
3. issue完了時のtest-and-lint実行を確認

### スクラム-02(01回目) レビューコメントの検討

#### 指摘された問題点

レビューコメントで以下の重要な問題点が指摘されました:

1. **現状のissue運用**:
   - issue単位でブランチを作成し、PRを出している
   - 1issue = 1ブランチ = 1PR

2. **案4の問題点**:
   - 「PRマージ前に未使用コードを解決」という要件が、現状では「issue完了時 = PRマージ前」を意味する
   - これでは結局issue単位での未使用コード解決になる
   - 粒度の細かいPR（デイリースクラム単位でのPR）ができない

3. **根本的な課題**:
   - issue運用自体の見直しが必要かもしれない
   - 1issue内で複数のPRを出すような運用への変更を検討すべきか？

#### 新しい改善案の提案

##### 案6: issue運用の変更 + デイリースクラム単位でのPR（新提案）

**運用変更:**
- 1issue = 複数のデイリースクラム = 複数のPR
- デイリースクラム単位でコミット・PR作成
- issue全体の完了時に最終的なクリーンアップ

**実装方法:**
1. デイリースクラム完了時:
   - `npm run test:all`: 必須
   - `npm run unused:check`: 警告のみ
   - デイリースクラム単位でコミット
   - デイリースクラム単位でPR作成（`feature/issue-089-daily-02`など）

2. issue完了時:
   - 全デイリースクラムのPRをマージ
   - `npm run test-and-lint`: 必須
   - 未使用コードを完全に解決
   - issueブランチをmainにマージ

**メリット:**
- 真の意味でデイリースクラム単位での粒度の細かいPR
- レビュー負荷の分散
- 段階的な品質向上
- issue全体で品質保証

**デメリット:**
- ワークフローが大幅に変わる
- ブランチ戦略の複雑化
- マージ手順が増える

**評価:** ★★★★☆

##### 案7: 警告のみの運用 + issue完了時チェック（現実的な妥協案）

**運用変更なし（現状維持）:**
- 1issue = 1ブランチ = 1PR

**実装方法:**
1. デイリースクラム完了時:
   - `npm run test:all`: 必須
   - `npm run unused:check`: 警告のみ
   - 未使用コードがあってもコミット・進捗記録可能

2. issue完了時（PRマージ前）:
   - `npm run test-and-lint`: 必須
   - すべての未使用コードを解決
   - **ただし、これは1issue内の最後のデイリースクラム完了時に実行**

**重要な変更点:**
- 各デイリースクラムでは未使用コードを許容
- issue内の最後のデイリースクラムで全て解決
- これにより、途中のデイリースクラムでは将来使う予定のコードを残せる

**メリット:**
- 運用変更が最小限
- 実装がシンプル
- デイリースクラム途中では未使用コードを気にせず進められる
- issue全体として品質保証される

**デメリット:**
- 「粒度の細かいPR」という要件は満たせない（1issue = 1PR のまま）
- レビュー負荷は分散されない

**評価:** ★★★☆☆

#### 推奨アプローチの再検討

**質問への回答として、2つのアプローチを提案:**

##### アプローチA: issue運用を変更する（案6）

**こんな場合に推奨:**
- 本当に粒度の細かいPRレビューを重視する
- レビュー負荷を分散したい
- 段階的な進捗を可視化したい

**必要な変更:**
- issue運用の大幅な見直し
- ブランチ戦略の変更（issue-089 → issue-089-daily-01, issue-089-daily-02...）
- PRワークフローの変更
- .clinerulesの大幅な修正

##### アプローチB: 現状運用を維持する（案7）

**こんな場合に推奨:**
- 運用変更のコストを抑えたい
- シンプルさを重視する
- 1issue内での柔軟な開発を優先

**必要な変更:**
- package.jsonに`unused:check`追加
- ワークフローの微修正のみ
- .clinerulesの軽微な修正

#### 次のステップ

開発者の判断を仰ぐ必要がある事項:

1. **issue運用を変更するか？**
   - 変更する → アプローチA（案6）で実装計画を策定
   - 変更しない → アプローチB（案7）で実装計画を策定

2. **「粒度の細かいPR」の優先度**
   - 高い → アプローチA推奨
   - 中程度 → アプローチB推奨

3. **運用変更のコスト許容度**
   - 許容できる → アプローチA可能
   - 抑えたい → アプローチB推奨

# ISSUEを通した相談事
<!-- 相談したいこと、質問したいこと、レビューしてほしいこと -->
<!-- について、体言止めでの相談ではなににどう答えればよいのか明確にならないので使わないでください-->
<!-- 相談は具体的な内容を記載してください。 -->
<!-- 質問は不明点を明確に記載してください。 -->
<!-- レビューしてほしいことは、レビュー対象を具体的に記載してください。 -->
<!-- また上記相談・質問・レビューのトピックが重複する場合は、まとめて記載してください。 -->

## issue運用変更に関する意思決定のお願い

レビューコメントで指摘された問題を解決するため、以下の2つのアプローチを提案しました:

### アプローチA: issue運用を変更（案6）
- 1issue内で複数のPRを出す運用に変更
- デイリースクラム単位でPR作成
- 真の意味での粒度の細かいPR実現

### アプローチB: 現状運用を維持（案7）
- 1issue = 1PR を維持
- デイリースクラム途中では未使用コードを許容
- issue完了時に全て解決

**お聞きしたいこと:**
1. issue運用を変更することについて、どのようにお考えですか？
2. 「粒度の細かいPR」の優先度はどの程度ですか？（レビュー負荷分散の必要性など）
3. 運用変更に伴うコスト（ワークフロー修正、学習コスト）は許容できますか？

この意思決定に基づいて、具体的な実装計画を策定します。

# 残タスク
<!-- issueの進捗に応じて記入 -->
