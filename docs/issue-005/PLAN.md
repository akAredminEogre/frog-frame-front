# Issueの計画

<!-- Issueの計画を立てます。ユーザーストーリーに分解し、一つ一つにタスクを洗い出します。-->


## Story-1: ユーザーとして右クリックメニューから「この要素を置換」を選択することにより、選択したテキストを含む要素全体を置換対象にできる

ユーザーがWebページ上でテキストを選択し、右クリックメニューから「この要素を置換」を選択すると、選択したテキストを含む最小のHTML要素全体がポップアップの「置換前」フィールドに反映される。
これにより、部分的なテキスト置換ではなく、要素単位での置換が可能になる。

### タスク

- [x] background.tsに新しいコンテキストメニューアイテム「この要素を置換」を追加 ✅ スクラム01完了
- [x] 既存の「この部分を置換」を削除し、新しい機能に置き換える ✅ スクラム01完了（当初の並列表示から変更）
- [x] 新しいメニューアイテムのIDを`context-menu-replace-dom-element`として設定 ✅ スクラム01完了（当初の`replace-element`から変更）

## Story-2: 開発者として選択されたテキストを含む最小のHTML要素を特定する機能により、正確な要素置換を実現する

選択されたテキストを含む最小のHTML要素を特定し、その要素のouterHTMLを取得する機能を実装する。
これにより、ユーザーが選択したテキストが含まれる適切な要素を自動的に判別できる。

### タスク

- [x] content.tsに`getElementSelectionInfo()`関数を実装 ✅ スクラム01完了
- [x] `window.getSelection()`を使用して選択範囲を取得 ✅ スクラム01完了
- [x] `commonAncestorContainer`で共通祖先要素を特定 ✅ スクラム01完了
- [x] テキストノードの場合は親要素を取得するロジックを実装 ✅ スクラム01完了
- [x] 対象要素の`outerHTML`を返す処理を実装 ✅ スクラム01完了

## Story-3: システムとして新しいメッセージタイプを処理することにより、背景スクリプトとコンテンツスクリプト間の通信を実現する

background.tsとcontent.ts間で新しい機能のためのメッセージ通信を実装する。
既存の`getSelection`とは区別して、新しい`getElementSelection`メッセージタイプで処理する。

### タスク

- [x] background.tsの`chrome.contextMenus.onClicked.addListener`で`context-menu-replace-dom-element`メニューの処理を追加 ✅ スクラム01完了
- [x] content.tsに`getElementSelection`メッセージタイプのハンドラを追加 ✅ スクラム01完了
- [x] 既存の`getSelection`処理と区別して実装 ✅ スクラム01完了
- [x] エラーハンドリングを適切に実装 ✅ スクラム01完了

## Story-4: 開発者として手動テストを実施することにより、新機能の品質を保証する

新しく実装した`getElementSelectionInfo()`関数について、DOM操作の複雑さを考慮し、実際のブラウザ環境での手動テストを実施して様々なHTML構造での動作を検証する。

### タスク

- [ ] テスト用HTMLファイルを作成して手動テスト環境を準備
- [ ] 単一要素内のテキスト選択の動作を手動で確認
- [ ] 複数要素にまたがるテキスト選択の動作を手動で確認
- [ ] ネストした要素での選択の動作を手動で確認
- [ ] エッジケース（選択なし、特殊文字など）を手動で確認

## Story-5: ユーザーとしてユーザーストーリーのシナリオが正常に動作することにより、期待通りの機能を利用できる

issue-005のユーザーストーリーで示されたHTMLサンプルでの動作確認を行い、「顧客満足を最優先」を選択した際に適切な要素全体が取得されることを検証する。

### タスク

- [ ] ユーザーストーリーのHTMLサンプルを用いた手動テストを実行
- [ ] 「顧客満足を最優先」を選択して右クリックメニューをテスト
- [ ] ポップアップに`<font>`要素全体が表示されることを確認
- [ ] 既存の「この部分を置換」機能が正常に動作することを確認
- [ ] 様々なWebサイトでの動作確認を実施
