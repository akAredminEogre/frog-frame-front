# ISSUE-089 PULL REQUEST

## タイトル
Lint設定のリファクタリング: 粒度の細かいPRを可能にするtest-and-checkスクリプトの導入

## 概要と理由

### 背景
現在のワークフローでは、タスク完了前に`test-and-lint`の実行を義務付けています。しかし、この運用では粒度の細かいPRを提出する際に、将来のissueで使用予定のクラスやメソッド、プロパティが「未使用コード」として削除されてしまう問題がありました。そのため、そのクラスを使うコードも同時に実装せざるを得ず、結果としてPRの粒度が粗くなっていました。

### 解決策
本PRでは、既存の`test-and-lint`(厳格モード)を維持しつつ、新たに`test-and-check`(警告モード)スクリプトを導入しました。これにより、以下が実現できます:

- **デイリースクラム完了時**: `test-and-check`で警告レベルのチェック(未使用コードは警告のみ)
- **issue完了時**: `test-and-lint`で厳格なチェック(未使用コードは削除)

この2段階アプローチにより、開発途中では将来使う予定のコードを残しつつ、issue全体として品質を保証する運用が可能になりました。

## 主な変更点

### 1. package.jsonのスクリプト追加
- **`test-and-check`(新規)**: 警告レベルのチェック
  - テスト実行: 必須(失敗時はエラー)
  - lint/knip/tsr: 警告のみ(失敗しても処理継続)
- **`test-and-lint`(既存維持)**: 厳格モードのチェック
  - すべてのチェックで失敗時はエラー

### 2. .clinerulesのワークフロー更新
- `test-and-lint-before-complete.md` → `test-and-check-before-complete.md`に変更
- `workflow:code-according-to-the-rules.md`の参照を更新
- `05-project-specific-rules.md`の参照を更新

### 3. 運用方針
- **現状運用を維持**: 1issue = 1PR
- **段階的な品質保証**: 
  - デイリースクラム単位では未使用コードを許容
  - issue完了時に全て解決

## テスト方法
[動作確認の手順]
- `docker compose exec frontend npm run test-and-check` で警告レベルのチェックを確認
  - テスト失敗時はエラー
  - lint/knip/tsr失敗時は警告のみ
- `docker compose exec frontend npm run test-and-lint` で厳格モードのチェックを確認
  - すべての失敗時にエラー
- 既存自動テストとlinterを同時に確認

## 補足
[追加の文脈や注意点]

### 検討プロセス
スクラム02では、複数の改善案(案1〜7)を検討し、開発者とのレビューを通じて最適なアプローチを決定しました。当初は「issue運用の変更(1issue内で複数PR)」も検討しましたが、運用変更のコストと現状維持のメリットを比較した結果、現状運用を維持する方針となりました。

### 実装の変遷
- 当初は`test-and-lint`の修正を試みましたが、最終的に`test-and-check`として新規スクリプトを追加する設計に変更
- これにより、既存の`test-and-lint`を使用している他の箇所への影響を最小限に抑えられました

### 動作確認結果
- test-and-check: 全テスト成功、警告なし
- test-and-lint: 全テスト成功、未使用コードなし
- 両スクリプトが問題なく共存することを確認済み

## 本スコープの対象外となったタスク

以下は検討したものの、本issueのスコープ外としました:

1. **issue運用の変更(案6)**: 1issue内で複数のデイリースクラム単位でPRを出す運用への変更
   - 理由: 運用変更のコストが高く、現状のアプローチで目的を達成可能と判断
2. **knipの設定カスタマイズ(案3, 5)**: 複数の設定ファイルやignoreパターンの管理
   - 理由: スクリプト分離のアプローチで十分な柔軟性を確保できたため

<!-- ユーザーが使うコマンド workflow:submit-pull-request -->
