window.getSelection()の抽象化とレイヤー分離によるテスト容易性向上
背景と問題点: 直接DOM API呼び出しの弊害
現在、content.ts内のElementSelectionInfo関数でブラウザのDOM APIであるwindow.getSelection()を直接呼び出しており、これがユニットテストを困難にしています。window.getSelection()は実行環境に依存した挙動をするため、テストコード中で選択状態を再現したりモックしたりするのが難しく、過度なセットアップや特殊なテスト環境（例えば実ブラウザやJSDOMの利用）を必要としてしまいます。結果として、インフラ依存の強いコードはテストの準備に過度な手間がかかるという問題が発生しています
learn.microsoft.com
learn.microsoft.com
。
抽象化の目的: DOM依存を隔離してテストしやすくする
ご認識のとおり、window.getSelection()の呼び出しを抽象化する目的はDOM APIという技術的詳細を切り離し、ユニットテストしやすくするためです。具体的には、ブラウザ環境に依存する処理を直接ビジネスロジックに書かず、間に抽象層やラッパーを挟むことで、テスト時にはその部分をモック・スタブに差し替えられるようにします。このように外部依存を分離することで、コアロジックは純粋な入力と出力でテストでき、テスト容易性が飛躍的に向上します。 実際、ソフトウェア設計の原則でも**「外部サービス（ブラウザAPIなど）はインフラ層に隠蔽し、自分たちの仕様（インターフェース）に従わせることで、コードを置き換え可能でテストしやすくする」**とされています
bespoyasov.me
。例えば、外部のWebサービス呼び出しに直接依存するのではなく抽象インターフェース経由にすることで、テスト時にはスタブ実装と差し替え可能になる、という指摘もあります
learn.microsoft.com
。同様に、ブラウザのwindow.getSelection()呼び出しも抽象化することで、テスト用に任意の選択状態を模擬できるようになります。
推奨プロジェクト構造での配置: どのレイヤーに切り出すべきか
結論から言えば、window.getSelection()をラップする処理は「インフラストラクチャ層」（あるいはプレゼンテーション層のUIヘルパー部分）に配置するのが望ましいです。理由は、この処理がブラウザという外部環境に対する技術的詳細であり、ドメインやアプリケーションの純粋なロジックから切り離すべき部分だからです。 一般的なレイヤードアーキテクチャやClean Architectureでは、以下のように責務を分離します:
ドメイン層/ビジネスロジック: 純粋なロジックのみを含み、環境依存やUI・DBといった詳細には依存しません。したがって、この層にwindow.getSelection()のようなブラウザAPI呼び出しは置くべきではありません。
アプリケーション層/ユースケース: ユースケースの遂行やドメインロジックのオーケストレーションを行いますが、やはり具体的な環境依存（ブラウザAPIなど）は直接含めず、必要なら抽象化されたインターフェース経由で利用します。
プレゼンテーション層/UI層: ユーザーとのやりとり部分です。ブラウザのDOM操作やイベント処理はこの層の責務ですが、テスト容易性を高めるには、直接ブラウザAPIを呼ぶのではなくラッパーやヘルパーをかませることが理想です。今回のElementSelectorやElementSelectionInfoは「UIコンテキスト内で選択要素を特定するロジック」と言えるため、この層に属すると考えられます。
インフラストラクチャ層: データベースアクセスやファイルIO、ネットワーク通信、ブラウザAPIなど外部環境とのやりとりを抽象化した実装を置く層です。window.getSelection()の呼び出しはブラウザ環境への直接依存なので、ここに属する典型的な処理と言えます。
bespoyasov.me
以上を踏まえると、window.getSelection()をラップした関数やクラスはインフラストラクチャ層に配置するのが適切です。プレゼンテーション層からインフラ層のこのラッパーを利用する形にすれば、UIロジックからブラウザAPI呼び出しの詳細が分離され、テストではその部分を差し替え可能になります。 なお、「推奨プロジェクト構造」において具体的にディレクトリ階層が決まっている場合（例えばinfrastructure/ディレクトリやservices/フォルダ等）、その中にSelectionServiceやBrowserSelectionといった命名でモジュールを作成し、window.getSelection()を内包するのが良いでしょう。
抽象化の方法: ラッパー関数またはインターフェース
抽象化の具体的な方法としては大きく2通り考えられます。(1) シンプルな関数/クラスによるラップか、(2) インターフェースの定義と依存性注入です。それぞれについて、現時点での改修コストと将来的な拡張性の観点から説明します。
1. ラッパー関数・ユーティリティクラスによる簡易抽象化
最小の改修で済ませたい場合、ユーティリティ関数またはクラスとしてwindow.getSelection()をラップする方法がおすすめです。具体的には、以下のような実装になります。
インフラ層（あるいはUIヘルパー用のユーティリティモジュール）に、新しいモジュールファイルを作成します。例: selection.tsもしくはSelectionService.tsなど。
そのモジュール内で getSelection() という関数（または静的メソッド）を定義し、実行時には単に window.getSelection() を呼び出して結果を返すようにします。
ts
コピーする
編集する
// selection.ts
export function getSelection(): Selection | null {
    return window.getSelection();
}
もしSelectionオブジェクトからさらに加工した情報を返す必要があるなら、この関数内で必要な処理を行いますが、ポイントは直接のDOM API呼び出しはこのモジュール内だけに閉じ込めることです。
content.tsやElementSelectorからは、従来 window.getSelection() を呼んでいた箇所をこの新しい関数呼び出しに置き換えます。例: import { getSelection } from '../infrastructure/selection'; ... const selection = getSelection(); のようにします。
こうしておけば、テストコード側ではこのモジュールをモックすることでwindow.getSelection()の挙動を自由に差し替えられます。例えばJestを使っているなら、jest.mock('path/to/selection.ts', () => ({ getSelection: jest.fn(() => dummySelection) }))のようにして、任意のダミーSelectionオブジェクトを返すモックを仕込めます。これにより、ブラウザ環境がなくても選択内容に依存するロジックをユニットテスト可能になります。
このアプローチはコード改修量が少なく、既存構造に大きな変更を加えないメリットがあります。現状インターフェース注入などを導入していないとのことですので、まずは単純なラッパー関数で切り出してテスト性を確保するのが良い選択肢でしょう。
2. 抽象インターフェースと依存性注入による柔軟な抽象化
もう一歩進んだ設計として、インターフェースを定義し依存性注入（DI）を用いる方法があります。将来的な拡張性を見据える場合はこちらが理想的です。
まず、ISelectionProviderなどの名前で選択取得機能のインターフェースを定義します。例えば:
ts
コピーする
編集する
interface ISelectionProvider {
    getSelection(): Selection | null;
}
インフラ層にこのインターフェースの実装クラスを作ります。例えばBrowserSelectionProviderのようなクラスを作成し、上記インターフェースを実装します。BrowserSelectionProvider.getSelection()内部でwindow.getSelection()を呼び出すように実装します。
ElementSelectorやElementSelectionInfoを使用する箇所では、直接window.getSelection()を呼ぶ代わりにISelectionProviderを経由するように変更します。具体的には、ElementSelectorにISelectionProvider型のオブジェクトを渡せるようにコンストラクタやメソッドの引数を変更します（これが依存性の注入です）。例えば:
ts
コピーする
編集する
class ElementSelector {
    constructor(private selectionProvider: ISelectionProvider) {}
    ...
    someMethod() {
        const selection = this.selectionProvider.getSelection();
        // 選択情報を使ったロジック
    }
}
そしてcontent.tsでElementSelectorを生成する際に、実装であるnew BrowserSelectionProvider()を渡します。
テスト時には、ISelectionProviderのモック実装（例えばDummySelectionProvider）を用意し、好きなようにgetSelection()が返す値を操作できます。これをElementSelectorに差し替えてやれば、ブラウザに依存しない形で選択処理のテストが可能になります。
この方法は多少コード量が増えますが、SOLID原則の一つである依存関係逆転の原則（DIP）に沿った設計となり、長期的には変更に強い構造になります。実際、外部APIとのやりとりを抽象インターフェース越しに行うことで、実装の置き換えやモックが容易になることが知られています
learn.microsoft.com
。 今回のケースでは「まずは最小の改修コストでテスト容易性を高めたい」という要件があるため、無理にインターフェース注入まで導入しなくても構いません。まずは (1) の方法で関数を切り出し、テストを書きやすくするだけでも十分効果があります。その上で、プロジェクト全体のアーキテクチャをClean ArchitectureやMVPに沿って発展させたい場合に、(2) の手法へリファクタリングしていくと良いでしょう。
content.tsやElementSelectorからの呼び出し方
上記の抽象化を行った後、既存のcontent.tsやElementSelectorからは新しく抽出した機能を呼び出す形に変更します。具体的な手順は次のとおりです。
ユーティリティ関数でラップした場合 – content.ts内で該当モジュールをインポートし、関数を呼び出します。例: import { getSelection } from '@/infrastructure/selection'; ... const sel = getSelection(); として取得したselを従来どおり後続のロジックで使います。ElementSelector内部で直接window.getSelection()を使っていたなら、代わりにこのユーティリティ関数をインポートして利用します。関数名やモジュール名はプロジェクトの命名規則に従って決めてください。重要なのは他の箇所から見ると動作は変わらず、内部で何をしているか（windowを叩いているかモックか）は意識しなくてよくなる点です。
インターフェース＋DIを導入した場合 – ElementSelectorのコンストラクタやメソッド引数でISelectionProviderを受け取るよう修正した後、content.tsでElementSelectorを生成する際に実装クラス（例えばnew BrowserSelectionProvider()）を渡します。例:
ts
コピーする
編集する
const selector = new ElementSelector(new BrowserSelectionProvider());
selector.doSomething(); // 内部で selectionProvider.getSelection() が使われる
こうしておけば、content.ts側の変更は依存を渡す一箇所だけで済み、他のロジックはそのまま利用できます。テスト時にはnew ElementSelector(dummySelectionProvider)のようにモックを渡せば良いだけです。
いずれの方法でも、呼び出し元から見るとwindow.getSelection()を直接呼んでいるのと同じインターフェース（メソッドシグネチャ）で扱えるようにしておくことがポイントです。そうすることでリファクタリングによる影響範囲を小さく留め、既存のロジックを大きく変えずにテスト容易性だけを向上させられます。
最小限の改修で得られるメリット
提案したアプローチにより、現時点で最小限のコード修正で次のメリットが得られます。
ユニットテストの簡素化: 選択テキスト取得部分をモック可能になるため、煩雑だったテストセットアップが軽減されます。例えば「テキスト選択→右クリック」のシナリオをテストする際、実際にDOM上で選択操作を再現しなくても、モックが返すダミー選択テキストでロジックの検証ができます。これは**「本質的でない部分（ブラウザ選択状態の再現）に時間を割かず、本来テストしたいビジネスロジックの検証に集中できる」**ことを意味します
learn.microsoft.com
learn.microsoft.com
。
コードの関心分離: ElementSelector/ElementSelectionInfoの役割である「UI上の選択範囲を特定するロジック」から、ブラウザAPI呼び出しという詳細が切り離されます。これにより、コードの見通しが良くなり責務が明確化します。将来的に他の方法で選択範囲を取得したくなった場合（例えば別のブラウザAPIや、サーバから選択情報をもらうような拡張がもし必要になった場合）でも、該当部分の実装を差し替えるだけで済みます。
Clean Architecture/MVPへの足がかり: 今回は長期的利点は二の次とのことですが、今回の変更はアーキテクチャ改善の第一歩でもあります。外部依存をインフラ層に隔離しインターフェース経由で利用する設計は、クリーンアーキテクチャやMVPと親和性が高く、今後他の部分も含めてリファクタしていくことで、さらなる可読性・保守性向上が期待できます。
以上のように、window.getSelection()の呼び出し箇所を適切なレイヤーに切り出して抽象化することで、現状のMVP開発においてテスト容易性を確保しつつ、将来的な拡張にも対応できる柔軟な構造を得ることができます。今回の要件であれば、まずはシンプルなラップ関数による実装で問題ありませんが、プロジェクトの規模やニーズに応じてインターフェースとDIを導入することも検討してみてください。テスト容易性と設計のバランスを取りながら、段階的にアーキテクチャを洗練させていくアプローチがおすすめです。