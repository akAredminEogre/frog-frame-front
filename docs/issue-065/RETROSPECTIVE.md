# 振り返り

このファイルでデイリースクラムの振り返りを行います。追記専用です。過去の内容を修正しないでください。

## スクラム01 の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- 既存のpopup/App.tsxの構造を体系的に調査・分析できた
- atomic designの分割候補（Atoms, Molecules, Organisms）を具体的に洗い出せた
- データフローを入力→処理→保存→フィードバックの流れで整理できた
- ビジネスロジック（UseCase層）を変更せずにUI層のみリファクタリングする方針を明確化できた
- 相談事項に対する回答を得て、次のスクラムでの方針が明確になった

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 調査・分析フェーズのため実際のコード変更は行わず、進捗が目に見えにくかった
- atomic designの具体的な実装イメージをより詳細に検討する必要がある
- 既存のスタイリング手法との整合性について、当初は迷いがあった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 調査結果を基に、具体的なコンポーネント実装を早期に着手する
- atomic designの原則に従い、責務分離を意識したコンポーネント設計を心がける
- Storybookでの実装時は、再利用性を重視した設計を行う

## スクラム02 の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- Storybookを活用したatomic designの実装が計画通り完了した
- CSS modulesによるスタイリング手法の統一により、保守性が向上した
- デザイントークンの定義により、一貫性のあるデザインシステムの基盤を構築できた
- 段階的なレビューとフィードバックにより、コード品質を継続的に改善できた
- 型安全性を重視したイベントハンドラーの実装により、TypeScriptの恩恵を活用できた
- 既存App.tsxとの統合がスムーズに行えた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 三項演算子を使った複雑なイベントハンドラーで、初期段階では型安全性が低下していた
- HTMLInputElementとHTMLTextAreaElementの型区別が不十分で、レビューで指摘を受けた
- Checkboxコンポーネントの表示順序について、最初は要件を正しく理解できていなかった
- コンポーネントの責務分離について、当初は設計が複雑化していた

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- イベントハンドラーは最初から型安全性を重視し、責務を明確に分離して実装する
- UIコンポーネントの要件は、実装前により詳細に確認し、デザインレビューを早めに行う
- レビューコメントを受ける前に、自己レビューで型安全性とコード品質をチェックする
- 新しいコンポーネント作成時は、atomic designの原則を厳密に適用し、再利用性を最優先に設計する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->


## スクラム04の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- EditRulePageのビジネスロジックをUseCaseレイヤーに分離し、クリーンアーキテクチャに準拠した設計を実現できた
- レビューコメントを受けて段階的に設計を改善するアプローチが効果的だった（11回の進捗で品質向上）
- ビジネスロジック（URLパターン前方一致判定）をdomain層に配置する設計改善ができた
- 正常系・異常系の両方のテストを実装し、テストカバレッジを向上させた
- tsrツールのエクスポート単位の未使用判定の仕様を理解し、適切に対応できた
- RewriteRuleのurlPatternを必須パラメータ化し、型安全性を向上させた
- メッセージング方式でのタブ内容更新機能を実装し、ルール編集後の自動反映を実現できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- tsconfig.tsr.jsonの設定方法について、最初は適切な除外設定を見つけられなかった
- RefreshAllTabsAfterRuleUpdateUseCaseで、最初はinfrastructure層のロジック（chrome.tabs.*）を直接実装していた
- URLパターンのフィルタリングロジックの配置場所について、application層とdomain層の責務分離に迷いがあった
- レビューを重ねることで正しい設計に辿り着いたが、初回から適切なレイヤード配置ができなかった
- Chrome Tabs APIの型をdomain層に持ち込まない設計について、当初は適切なアプローチを見つけられなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 実装開始前に、各ロジックがどのレイヤーに属するべきかを明確に設計する
- infrastructure層への依存を避け、ポート＆アダプターパターンを最初から適用する
- ビジネスロジックはdomain層、オーケストレーションはapplication層という原則を徹底する
- 外部API（Chrome API等）の型をdomain層に持ち込まない設計を心がける
- レビュー前の自己レビューで、レイヤードアーキテクチャの原則を満たしているか確認する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->


## スクラム03の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- レビューフィードバックに基づく迅速な対応と改善ができた
- Chrome Storage APIを使用した実際のストレージ機能実装により、ダミーデータから本格的な実装への移行が完了した
- コンポーネント統合によるコード重複の排除（EditRewriteRuleFormをRewriteRuleFormに統合）
- 既存コンポーネント（RulesApp.tsx）への機能統合により、アーキテクチャの一貫性を保った
- E2Eテストの拡充により、編集フローの動作を保証できる体制が整った
- 8回の進捗で段階的に機能を実装・改善するアプローチが効果的だった

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 最初に作成したEditRewriteRuleFormが結局RewriteRuleFormと統合され、作り直しとなった
- RewriteRuleListコンポーネントを作成したが、既存のRulesApp.tsxと重複していることが後から判明し削除した
- ポップアップにルール一覧を表示する実装を行ったが、不要であることが判明し削除した
- E2EテストのURL指定方法について、最初はハードコードしていたが、fixturesを使用する方法に修正が必要だった
- 実装前に既存コンポーネントとの統合可能性を十分に検討できていなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 新規コンポーネント作成前に、既存コンポーネントの拡張可能性を必ず確認する
- 実装開始前に既存の類似機能やコンポーネントを調査し、統合可能性を検討する
- E2Eテストは実装と並行して作成し、早期にフィードバックを得るようにする
- レビュー時に指摘される前に、コード重複や統合可能性を自己チェックする
- UIの要否について、実装前にユーザー体験の観点から検討する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->


## スクラム05の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- DRY原則とSRPに従った設計改善により、コードの保守性が大幅に向上した
- 段階的なリファクタリング（getById実装変更→ドメイン層統合→リポジトリ層統合）が効果的だった
- エラーハンドリングをドメイン層に集約し、呼び出し側のnullチェックを不要にできた
- テストディレクトリの統合により、テストコードの重複を排除できた
- 全てのテスト（ユニット261件、E2E8件）が成功し、リグレッションを防げた
- Knipで未使用コードが検出されず、クリーンな状態を維持できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- ドメイン層のadd()/update()を統合した後、リポジトリ層にも同様の問題が残っていることに気づかなかった
- レビューで2回連続で同様の指摘（ドメイン層→リポジトリ層）を受けることになった
- リファクタリング時に影響範囲を十分に確認できていなかった
- 最初から全体のアーキテクチャを見渡して、同様のパターンを洗い出せなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- レビューコメントを受けた際は、同様のパターンが他のレイヤーや他のクラスにないか全体を確認する
- リファクタリング時は、対象箇所だけでなく依存関係のある全レイヤーを見渡す
- メソッド名の統合などの変更を行う際は、呼び出し側とインターフェースの整合性を最初から確認する
- レビュー前の自己レビューで、同じ設計原則違反が他にないかをチェックする


---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->

## スクラム06の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- コーディング規約に準拠したテストコードへのリファクタリングが完了した
- 配列ベーステストへの変換により、テストケースの管理が統一的で保守しやすくなった
- テストファイルの分割（true/falseで別ファイル）により、テストの意図がより明確になった
- JSDocの更新により、テストの実際の動作を正確に記述できた
- beforeEach/afterEachの追加により、テスト間でのモック状態の漏れを防げた
- 全8テストが正常に通過し、機能を維持したままリファクタリングできた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 本質的に無関係なパラメータの整理という概念を最初から理解できていなかった
- 期待値の配置場所について、最初は配列に含めていたが、forEachのスコープに移動することでより簡潔になることに気づかなかった
- コーディング規約の全ての項目を最初から完全に把握できていなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- テストコード作成時は、最初からコーディング規約を確認し、準拠した形で実装する
- テストケースの配列を設計する際は、本質的に関係のあるパラメータのみを含め、無関係なものはforEach内で定義する
- 期待値が全て同じ場合は、配列から除外してforEach内で定義することを検討する
- レビュー前に自己レビューで、コーディング規約の全項目を満たしているか確認する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->