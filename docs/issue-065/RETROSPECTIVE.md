# 振り返り

このファイルでデイリースクラムの振り返りを行います。追記専用です。過去の内容を修正しないでください。
追記のときは最後尾に追加してください。

## スクラム01 の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- 既存のpopup/App.tsxの構造を体系的に調査・分析できた
- atomic designの分割候補（Atoms, Molecules, Organisms）を具体的に洗い出せた
- データフローを入力→処理→保存→フィードバックの流れで整理できた
- ビジネスロジック（UseCase層）を変更せずにUI層のみリファクタリングする方針を明確化できた
- 相談事項に対する回答を得て、次のスクラムでの方針が明確になった

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 調査・分析フェーズのため実際のコード変更は行わず、進捗が目に見えにくかった
- atomic designの具体的な実装イメージをより詳細に検討する必要がある
- 既存のスタイリング手法との整合性について、当初は迷いがあった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 調査結果を基に、具体的なコンポーネント実装を早期に着手する
- atomic designの原則に従い、責務分離を意識したコンポーネント設計を心がける
- Storybookでの実装時は、再利用性を重視した設計を行う

## スクラム02 の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- Storybookを活用したatomic designの実装が計画通り完了した
- CSS modulesによるスタイリング手法の統一により、保守性が向上した
- デザイントークンの定義により、一貫性のあるデザインシステムの基盤を構築できた
- 段階的なレビューとフィードバックにより、コード品質を継続的に改善できた
- 型安全性を重視したイベントハンドラーの実装により、TypeScriptの恩恵を活用できた
- 既存App.tsxとの統合がスムーズに行えた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 三項演算子を使った複雑なイベントハンドラーで、初期段階では型安全性が低下していた
- HTMLInputElementとHTMLTextAreaElementの型区別が不十分で、レビューで指摘を受けた
- Checkboxコンポーネントの表示順序について、最初は要件を正しく理解できていなかった
- コンポーネントの責務分離について、当初は設計が複雑化していた

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- イベントハンドラーは最初から型安全性を重視し、責務を明確に分離して実装する
- UIコンポーネントの要件は、実装前により詳細に確認し、デザインレビューを早めに行う
- レビューコメントを受ける前に、自己レビューで型安全性とコード品質をチェックする
- 新しいコンポーネント作成時は、atomic designの原則を厳密に適用し、再利用性を最優先に設計する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->


## スクラム04の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- EditRulePageのビジネスロジックをUseCaseレイヤーに分離し、クリーンアーキテクチャに準拠した設計を実現できた
- レビューコメントを受けて段階的に設計を改善するアプローチが効果的だった（11回の進捗で品質向上）
- ビジネスロジック（URLパターン前方一致判定）をdomain層に配置する設計改善ができた
- 正常系・異常系の両方のテストを実装し、テストカバレッジを向上させた
- tsrツールのエクスポート単位の未使用判定の仕様を理解し、適切に対応できた
- RewriteRuleのurlPatternを必須パラメータ化し、型安全性を向上させた
- メッセージング方式でのタブ内容更新機能を実装し、ルール編集後の自動反映を実現できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- tsconfig.tsr.jsonの設定方法について、最初は適切な除外設定を見つけられなかった
- RefreshAllTabsAfterRuleUpdateUseCaseで、最初はinfrastructure層のロジック（chrome.tabs.*）を直接実装していた
- URLパターンのフィルタリングロジックの配置場所について、application層とdomain層の責務分離に迷いがあった
- レビューを重ねることで正しい設計に辿り着いたが、初回から適切なレイヤード配置ができなかった
- Chrome Tabs APIの型をdomain層に持ち込まない設計について、当初は適切なアプローチを見つけられなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 実装開始前に、各ロジックがどのレイヤーに属するべきかを明確に設計する
- infrastructure層への依存を避け、ポート＆アダプターパターンを最初から適用する
- ビジネスロジックはdomain層、オーケストレーションはapplication層という原則を徹底する
- 外部API（Chrome API等）の型をdomain層に持ち込まない設計を心がける
- レビュー前の自己レビューで、レイヤードアーキテクチャの原則を満たしているか確認する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->


## スクラム03の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- レビューフィードバックに基づく迅速な対応と改善ができた
- Chrome Storage APIを使用した実際のストレージ機能実装により、ダミーデータから本格的な実装への移行が完了した
- コンポーネント統合によるコード重複の排除（EditRewriteRuleFormをRewriteRuleFormに統合）
- 既存コンポーネント（RulesApp.tsx）への機能統合により、アーキテクチャの一貫性を保った
- E2Eテストの拡充により、編集フローの動作を保証できる体制が整った
- 8回の進捗で段階的に機能を実装・改善するアプローチが効果的だった

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 最初に作成したEditRewriteRuleFormが結局RewriteRuleFormと統合され、作り直しとなった
- RewriteRuleListコンポーネントを作成したが、既存のRulesApp.tsxと重複していることが後から判明し削除した
- ポップアップにルール一覧を表示する実装を行ったが、不要であることが判明し削除した
- E2EテストのURL指定方法について、最初はハードコードしていたが、fixturesを使用する方法に修正が必要だった
- 実装前に既存コンポーネントとの統合可能性を十分に検討できていなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 新規コンポーネント作成前に、既存コンポーネントの拡張可能性を必ず確認する
- 実装開始前に既存の類似機能やコンポーネントを調査し、統合可能性を検討する
- E2Eテストは実装と並行して作成し、早期にフィードバックを得るようにする
- レビュー時に指摘される前に、コード重複や統合可能性を自己チェックする
- UIの要否について、実装前にユーザー体験の観点から検討する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->


## スクラム05の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- DRY原則とSRPに従った設計改善により、コードの保守性が大幅に向上した
- 段階的なリファクタリング（getById実装変更→ドメイン層統合→リポジトリ層統合）が効果的だった
- エラーハンドリングをドメイン層に集約し、呼び出し側のnullチェックを不要にできた
- テストディレクトリの統合により、テストコードの重複を排除できた
- 全てのテスト（ユニット261件、E2E8件）が成功し、リグレッションを防げた
- Knipで未使用コードが検出されず、クリーンな状態を維持できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- ドメイン層のadd()/update()を統合した後、リポジトリ層にも同様の問題が残っていることに気づかなかった
- レビューで2回連続で同様の指摘（ドメイン層→リポジトリ層）を受けることになった
- リファクタリング時に影響範囲を十分に確認できていなかった
- 最初から全体のアーキテクチャを見渡して、同様のパターンを洗い出せなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- レビューコメントを受けた際は、同様のパターンが他のレイヤーや他のクラスにないか全体を確認する
- リファクタリング時は、対象箇所だけでなく依存関係のある全レイヤーを見渡す
- メソッド名の統合などの変更を行う際は、呼び出し側とインターフェースの整合性を最初から確認する
- レビュー前の自己レビューで、同じ設計原則違反が他にないかをチェックする


---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->

## スクラム06の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- コーディング規約に準拠したテストコードへのリファクタリングが完了した
- 配列ベーステストへの変換により、テストケースの管理が統一的で保守しやすくなった
- テストファイルの分割（true/falseで別ファイル）により、テストの意図がより明確になった
- JSDocの更新により、テストの実際の動作を正確に記述できた
- beforeEach/afterEachの追加により、テスト間でのモック状態の漏れを防げた
- 全8テストが正常に通過し、機能を維持したままリファクタリングできた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 本質的に無関係なパラメータの整理という概念を最初から理解できていなかった
- 期待値の配置場所について、最初は配列に含めていたが、forEachのスコープに移動することでより簡潔になることに気づかなかった
- コーディング規約の全ての項目を最初から完全に把握できていなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- テストコード作成時は、最初からコーディング規約を確認し、準拠した形で実装する
- テストケースの配列を設計する際は、本質的に関係のあるパラメータのみを含め、無関係なものはforEach内で定義する
- 期待値が全て同じ場合は、配列から除外してforEach内で定義することを検討する
- レビュー前に自己レビューで、コーディング規約の全項目を満たしているか確認する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->

## スクラム07の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- CurrentTabからTabへの大規模なリネーム作業を、コミットを2つに分割して管理できた（参照変更のみ vs 実装変更含む）
- 30ファイル以上の変更にもかかわらず、全てのユニットテスト（265個）が成功し、リグレッションを防げた
- IChromeTabsService.tsのTabインターフェースを削除し、domain層のTabクラスに統一することで、型の一元管理を実現できた
- クラス名のリネームと同時に、テストディレクトリも適切にリネームし、一貫性を保った
- TypeScriptのコンパイルエラーなし、Knipでの未使用コード検出もなし、という品質を維持できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 大規模なリネーム作業で30ファイル以上に影響が出たため、ステージング対象の判断に時間がかかった
- 「参照変更のみ」と「実装変更を含む」の境界線の判断が難しく、ユーザーに確認を求めることになった
- 変数名変更やログメッセージ変更が含まれるファイルをどこまでステージングするか、方針が明確でなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 大規模リファクタリング（複数ファイルに影響）を行う前に、影響範囲を調査し、コミット分割の方針を明確にする
- リネーム作業時は、「import文と型参照の変更のみ」「変数名やメッセージの変更」「ロジック変更」を事前に分類する
- ステージング判断に迷う場合は、実装開始前にコミット分割の方針をユーザーと合意する
- レビュー前に自己チェックで、各ファイルの変更内容を分類し、適切なコミット分割ができているか確認する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->

## スクラム08の振り返り
<!-- KPT法で振り替りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- Tabsファーストクラスコレクションの導入により、ドメインロジックの適切な集約ができた
- Tab.matchesRuleメソッドの追加により、URL判定ロジックをTabクラスに移管し、単一責任の原則を実現できた
- IChromeTabsService.queryTabsの返り値をTabsコレクションに変更し、型安全性を向上させた
- filterTargetTabsメソッドをTabsコレクションに移管し、ビジネスロジックのカプセル化を実現できた
- 全テスト（RefreshAllTabsAfterRuleUpdateUseCase 4/4、Tab.matchesRule 3/3）が成功し、リファクタリングの安全性を保証できた
- レビューコメント（設計相談）に対して、DDDとClean Architectureの原則に基づいた明確な回答を提供できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- sendMessageToTabsメソッドをTabsコレクションに組み込むべきか、という設計上の疑問が生じた
- Value ObjectからInfrastructure層の処理を呼び出すことの可否について、判断に迷いがあった
- レイヤードアーキテクチャにおける各層の責務について、常に明確に理解できているわけではない

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- Value Objectの責務（不変なドメイン概念の表現、純粋な値の比較・計算・変換）を常に意識する
- メソッド配置を検討する際は、副作用の有無と依存関係の方向を最初に確認する
- Infrastructure層への依存が必要な処理は、Application層のUseCaseに配置するという原則を徹底する
- 設計上の疑問が生じた際は、DDDとClean Architectureの基本原則に立ち返って判断する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->

## スクラム09の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- 'applyAllRules'メッセージ送信ロジックをinfrastructure層のChromeTabsServiceに集約し、コードの重複を排除できた
- IChromeTabsService.sendApplyAllRulesMessage(tab: Tab)の導入により、3箇所の重複コードを統一できた
- 既存の使用箇所(RefreshAllTabsAfterRuleUpdateUseCase、tabs.onUpdated、messageHandlers)を新しいメソッドに置き換え、保守性を向上させた
- 全テスト(73ファイル、268テスト)が成功し、リファクタリングの安全性を確保できた
- TypeScriptコンパイルエラーなし、品質を維持できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- テストファイルの分割作業で、一時的にregistration.test.tsとonUpdatedListenerCallback.test.tsを作成したが、最終的にユーザーによってすべて削除されることになった
- テストファイルの分割の必要性や方針について、事前に十分な確認ができていなかった
- 作業記録(PROGRESS-09-01.md)で、削除されたテストファイルについての記述修正が必要になった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- テストファイルの分割や構造変更を行う前に、その必要性と影響範囲をユーザーに確認する
- リファクタリング作業では、コード変更とテスト変更を分けて計画し、段階的に進める
- 作業記録は現状を正確に反映するよう、最終状態を確認してから記述する
- Infrastructure層へのロジック集約パターンを他の箇所にも適用できないか確認する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->

## スクラム10の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- レビューフィードバックに基づく段階的な設計改善が効果的だった（4回のレビューで最適なアーキテクチャに到達）
- OpenRuleEditPageUseCaseの導入により、application層にビジネスロジックを適切に集約できた
- privateメソッドによるinfrastructure層の実装詳細隠蔽により、application層からの依存を最小化できた
- テストコーディング規約に従い、infrastructure層のbrowserカテゴリのテストを削除し、無駄なテストコードを排除できた
- 最終的に270件の全テストが成功し、品質を維持できた
- クリーンアーキテクチャの原則に従い、レイヤー間の依存関係を適切に管理できた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 最初の実装でinfrastructure層のメソッド(getEditPageUrl, createTab)をIChromeTabsServiceに公開してしまった
- application層からinfrastructure層の実装詳細が見える設計になっており、レビューで指摘を受けた
- レビューを4回経て最終的にprivateメソッドに変更したが、初期設計で適切な隠蔽ができなかった
- infrastructure層のテストファイルを作成した後に、テストコーディング規約に従って削除することになり、無駄な作業が発生した
- インターフェースに公開すべきメソッドの粒度について、最初から適切な判断ができなかった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- infrastructure層の実装詳細は最初からprivateメソッドとして隠蔽し、application層には高レベルの操作のみを公開する
- インターフェース設計時に、各メソッドの公開範囲を慎重に検討し、必要最小限の公開を心がける
- テストコーディング規約を実装前に確認し、テスト必須対象外のカテゴリには最初からテストを作成しない
- レビュー前の自己レビューで、レイヤー間の依存関係と責務分離を確認し、実装詳細が漏れていないかチェックする
- ポート＆アダプターパターンを適用する際は、アダプター(infrastructure層)の内部実装をポート(インターフェース)に露出させない設計を徹底する

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->

## スクラム11の振り返り
<!-- KPT法で振り返りを行なってください -->

### Keep
<!-- うまく行ったこと、続けていきたいこと -->
- 10回のレビューサイクルを通じて、段階的にコード品質を向上させることができた
- クリーンアーキテクチャとDRY原則に従った設計改善が効果的だった（EditRulePage.tsxからRewriteRuleエンティティへの依存削除→型の統一→DI適用→ユースケース統合）
- RewriteRuleParams型の一元管理により、コードベース全体での型の一貫性を実現できた
- RewriteRule.fromParams()ファクトリメソッドの導入により、パラメータ展開の重複コードを削減できた
- DIパターンの一貫した適用により、手動インスタンス化を排除し、テスタビリティが向上した
- UpdateRewriteRuleUseCaseへのタブ更新ロジック統合により、責任の明確化とコードの簡潔化を実現できた
- 不要になったRefreshAllTabsAfterRuleUpdateUseCaseを適切に削除し、コードベースをクリーンに保てた
- 全テスト（266件）が成功し、リグレッションを防げた

### Problem
<!-- 問題点、苦労したこと、レビューで指摘を受けたこと -->
- 個別パラメータ→オブジェクト化→オブジェクト直接渡し→型の統一と、段階的な指摘を受けることになった
- 最初から型の重複（WET）を認識できず、3箇所で同じ構造の型を定義していた
- LoadRewriteRuleForEditUseCaseのDI対応後も、他のUseCaseの手動インスタンス化が残っていた
- ユースケースの統合（UpdateRewriteRuleUseCase + RefreshAllTabsAfterRuleUpdateUseCase）についても後から指摘を受けた
- 初期設計の段階で、最終的な理想形（型の統一、DI適用、ユースケース統合）を見通せなかった
- レビューごとに改善を重ねたが、最初からこれらの原則を適用できていれば効率的だった

### Try
<!-- 次回やってみたいこと -->
<!-- タスクベースではなく、行動ルールとして記載してください。 -->
- 実装前にコードベース全体を見渡し、型の重複や設計パターンの適用箇所を洗い出す
- パラメータ設計時は、最初からオブジェクト化と型の統一を検討し、DRY原則を徹底する
- 新規クラス作成時は最初からDIパターンを適用し、手動インスタンス化を避ける
- 複数のユースケースが連続して呼び出される場合、統合可能性を事前に検討する
- レビュー前の自己レビューで、型の重複、設計原則違反、DIパターン未適用箇所がないか確認する
- 段階的改善ではなく、最初から理想的なアーキテクチャを目指す設計を心がける

---
<!-- ユーザーが使うコマンド workflow:commit-daily-scrum -->