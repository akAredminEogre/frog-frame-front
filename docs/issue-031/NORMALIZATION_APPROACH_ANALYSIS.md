# 正規化アプローチの比較分析

## 現在のアプローチ vs 提案された限定的アプローチ

### 現在のアプローチ（全空白除去）
```typescript
private normalize(text: string): string {
  return text.replace(/\s+/g, '');
}
```

### 提案されたアプローチ（限定的正規化）
```typescript
private normalize(text: string): string {
  // `<`の直前と`>`の直後の空白のみ除去
  return text.replace(/\s*</g, '<').replace(/>\s*/g, '>');
}
```

## 具体例での比較

### 例1: HTMLタグの属性
**元のHTML**: `<h1 class="title main">テスト</h1>`
**ユーザー入力**: `<h1 class="title main">テスト</h1>`

- **現在のアプローチ**: 
  - 正規化後: `<h1class="titlemain">テスト</h1>`
  - マッチ: ❌（属性内の空白が除去されるため不一致）

- **提案アプローチ**:
  - 正規化後: `<h1 class="title main">テスト</h1>`
  - マッチ: ✅

### 例2: タグ前後の改行
**元のHTML**: 
```html
<h1>
  アジャイルソフトウェア開発宣言
</h1>
```
**ユーザー入力**: `<h1>アジャイルソフトウェア開発宣言</h1>`

- **現在のアプローチ**:
  - 正規化後: `<h1>アジャイルソフトウェア開発宣言</h1>`
  - マッチ: ✅

- **提案アプローチ**:
  - 正規化後: `<h1>アジャイルソフトウェア開発宣言</h1>`
  - マッチ: ✅

### 例3: テキスト内の意図的な空白
**元のHTML**: `<p>Hello World</p>`
**ユーザー入力**: `<p>Hello World</p>`

- **現在のアプローチ**:
  - 正規化後: `<p>HelloWorld</p>`
  - マッチ: ❌（テキスト内空白が除去されるため不一致）

- **提案アプローチ**:
  - 正規化後: `<p>Hello World</p>`
  - マッチ: ✅

## 利点の分析

### 提案アプローチの利点

#### 1. HTMLの意味論的整合性の保持
- **属性の空白保持**: `class="btn primary"`のような複数のCSSクラスが正しく認識される
- **テキストコンテンツの保持**: 「Hello World」のような意図的な空白が保持される
- **HTMLの構造保持**: より自然なHTML構造として認識される

#### 2. ユーザビリティの向上
- **直感的**: ユーザーがHTMLを書く際の自然な記述と一致しやすい
- **エラーの削減**: 属性やテキスト内容での予期しないマッチ失敗を防ぐ
- **柔軟性**: より多様なHTMLパターンに対応可能

#### 3. 精密性の向上
- **対象限定**: 真に問題となるタグ前後の空白のみを対象とする
- **副作用の削減**: HTML内容への意図しない影響を最小化

### 現在アプローチの利点
- **シンプル**: 実装が簡単で理解しやすい
- **確実性**: 空白の問題を完全に排除する
- **テスト済み**: 現在のテストケースで検証済み

## 問題点の分析

### 提案アプローチの問題点

#### 1. 複雑なケースでの課題
- **ネストした空白**: `<div> <p>text</p> </div>`のような場合の処理
- **コメントや特殊文字**: `<!-- comment -->`やCDATAセクションでの挙動
- **不完全なHTML**: 開きタグのみや閉じタグのみの場合の処理

#### 2. テストケースの大幅変更
- **既存テストの修正**: 現在のテストケースがほぼ全て修正対象
- **新しいテストケース**: 属性やテキスト内容を含むケースの追加が必要

#### 3. パフォーマンスの考慮
- **正規表現の複雑化**: 2つの置換処理が必要
- **処理時間**: わずかながら処理時間の増加

### 現在アプローチの問題点
- **過度な正規化**: 本来保持すべき空白まで除去
- **HTMLの破綻**: 属性内の空白除去によるHTML構造の破壊
- **ユーザビリティ**: 直感的でない動作

## 推奨案

### 段階的移行アプローチ

1. **Phase 1: 新実装の並行実装**
   - 現在の`NormalizedString`を`LegacyNormalizedString`にリネーム
   - 新しい限定的正規化を`NormalizedString`として実装
   - 両方のテストを並行実行

2. **Phase 2: テストケースの段階的移行**
   - 新しいアプローチ用のテストケースを追加
   - 既存テストケースを段階的に新しいロジックに対応

3. **Phase 3: 完全移行**
   - レガシーコードの削除
   - ドキュメントの更新

### 提案される新しい正規化ロジック

```typescript
private normalize(text: string): string {
  return text
    // タグ直前の空白を除去: \s*< → <
    .replace(/\s*</g, '<')
    // タグ直後の空白を除去: >\s* → >
    .replace(/>\s*/g, '>');
}
```

### 追加考慮事項

1. **自己完結型タグ**: `<br />`や`<img src="..." />`への対応
2. **XMLスタイルタグ**: `<tag/>`形式への対応  
3. **エスケープ文字**: `&lt;`、`&gt;`への配慮

## 結論

**提案された限定的正規化アプローチを推奨します。**

理由:
- HTMLの意味論的整合性を保持
- ユーザビリティの大幅向上  
- より精密で予測可能な動作
- 元の課題（タグ前後の改行問題）は解決される

実装時の注意点:
- 既存テストの段階的更新
- 新しいエッジケースへの対応
- パフォーマンステストの実施
